-- Key System Implementation
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Players = game:GetService('Players')
local StarterGui = game:GetService('StarterGui')

-- Constants
local Constants = {
    DISCORD_URL = 'https://discord.gg/5ARTQYGvnX',
    VALID_KEY = 'WBUx', -- Updated key
    KEY_FILE = 'wbuhub/key.txt',
}

-- Notify function
local function notify(title, text, duration)
    pcall(function()
        StarterGui:SetCore('SendNotification', {
            Title = title or 'Key System',
            Text = text or '',
            Duration = duration or 3,
        })
    end)
end

-- Check saved key
local savedKey = nil
local keyValidated = false
if isfile and readfile then
    if isfile(Constants.KEY_FILE) then
        savedKey = readfile(Constants.KEY_FILE)
        if savedKey == Constants.VALID_KEY then
            keyValidated = true
            notify('Success', 'Valid key found! Loading script...', 3)
        end
    end
end

-- Create Key System GUI if key not validated
if not keyValidated then
    local KeyWindow = Rayfield:CreateWindow({
        Name = 'wbuhub Key System',
        LoadingTitle = 'wbuhub - Key Verification',
        LoadingSubtitle = 'Enter your key to proceed',
        ConfigurationSaving = { Enabled = false },
        Discord = {
            Enabled = true,
            Invite = Constants.DISCORD_URL:match('https://discord%.gg/(.+)')
                or '5ARTQYGvnX',
            RememberJoins = true,
        },
        KeySystem = false,
    })

    local KeyTab = KeyWindow:CreateTab('Key Input')

    -- Key Input
    KeyTab:CreateInput({
        Name = 'Enter Key',
        PlaceholderText = 'Type your key here...',
        RemoveTextAfterFocusLost = false,
        Callback = function(input)
            if input == Constants.VALID_KEY then
                if writefile then
                    pcall(function()
                        writefile(Constants.KEY_FILE, input)
                    end)
                end
                notify('Success', 'Key verified! Loading script...', 3)
                keyValidated = true
                KeyWindow:Destroy()
            else
                notify(
                    'Error',
                    'Invalid key! Get a valid key from our Discord.',
                    5
                )
            end
        end,
    })

    -- Discord Button
    KeyTab:CreateButton({
        Name = 'Join Discord for Key',
        Callback = function()
            if setclipboard then
                pcall(function()
                    setclipboard(Constants.DISCORD_URL)
                    notify(
                        'Info',
                        'Discord invite copied! Paste it in your browser.',
                        3
                    )
                end)
            else
                notify('Info', 'Join Discord: ' .. Constants.DISCORD_URL, 5)
            end
        end,
    })

    -- Auto-copy Discord link on load
    if setclipboard then
        pcall(function()
            setclipboard(Constants.DISCORD_URL)
            notify(
                'Info',
                'Discord invite copied to clipboard! Join for key updates.',
                5
            )
        end)
    end

    -- Initial notification
    notify('wbuhub', 'Enter your key to access the script!', 4)

    -- Wait for key validation
    while not keyValidated do
        task.wait(0.5)
    end
end

-- Original Script (with modified Autofarm tab update loop)
local Window = Rayfield:CreateWindow({
    Name = 'wbuhub - Armless Detective',
    LoadingTitle = 'wbuhub - armless detective',
    LoadingSubtitle = 'by wbuhub',
    ConfigurationSaving = {
        Enabled = true,
        FolderName = 'wbuhub',
        FileName = 'config',
    },
    Discord = {
        Enabled = true,
        Invite = '5ARTQYGvnX',
        RememberJoins = true,
    },
    KeySystem = false,
})
-- Tabs
local AutofarmTab = Window:CreateTab('Autofarm')
local EspTab = Window:CreateTab('ESP')
local GameValuesTab = Window:CreateTab('Game Values')
-- =======================
-- SETTINGS
-- =======================
local SETTINGS = {
    DiscordURL = 'https://discord.gg/5ARTQYGvnX',
    TimerUpdateRate = 0.5,
    SettingsFile = 'wbuhub-sets.txt',
}
-- =======================
-- SERVICES
-- =======================
local Players = game:GetService('Players')
local RS = game:GetService('ReplicatedStorage')
local Workspace = game:GetService('Workspace')
local StarterGui = game:GetService('StarterGui')
local LocalPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local RunService = game:GetService('RunService')
-- =======================
-- SAFETY CHECK
-- =======================
local valuesFolder = RS:FindFirstChild('Values')
local guiltySuspect = valuesFolder
    and valuesFolder:FindFirstChild('GuiltySuspect')
if not guiltySuspect then
    pcall(function()
        StarterGui:SetCore('SendNotification', {
            Title = 'wbuhub - Non Supported Game',
            Text = 'This game is not supported by wbuhub AutoFarm.',
            Duration = 5,
        })
    end)
    warn('[wbuhub] Non supported game. Script aborted.')
    return
end
-- =======================
-- LOAD SAVED SETTINGS
-- =======================
local autoExecEnabled = false
if isfile and readfile and writefile then
    if isfile(SETTINGS.SettingsFile) then
        local content = readfile(SETTINGS.SettingsFile)
        if content:match('AutoExec%(true%)') then
            autoExecEnabled = true
        end
    else
        writefile(
            SETTINGS.SettingsFile,
            '-- wbuhub loader settings\n-- https://discord.gg/5ARTQYGvnX\nAutoExec(false)'
        )
    end
else
    warn('[wbuhub] File functions not available. AutoExec default to false.')
end
local function saveAutoExec()
    if writefile then
        writefile(
            SETTINGS.SettingsFile,
            '-- wbuhub loader settings\n-- https://discord.gg/5ARTQYGvnX\nAutoExec('
                .. tostring(autoExecEnabled)
                .. ')'
        )
    end
end
-- =======================
-- AUTOFARM TAB
-- =======================
local moneyLabel = AutofarmTab:CreateLabel('Money: 0')
local candyLabel = AutofarmTab:CreateLabel('Candy: 0')
local timerLabel = AutofarmTab:CreateLabel('Timer: 0:00:00')
local guiltyLabel = AutofarmTab:CreateLabel('Guilty Suspect: Unknown')
local AutoFarmToggle = AutofarmTab:CreateToggle({
    Name = 'AutoFarm',
    CurrentValue = autoExecEnabled,
    Flag = 'AutoFarmToggle',
    Callback = function(Value)
        autoExecEnabled = Value
        saveAutoExec()
    end,
})
local AutoLobbyButton = AutofarmTab:CreateButton({
    Name = 'Auto Lobby',
    Callback = function()
        runLobbyRoutine()
    end,
})
local AutoGuessButton = AutofarmTab:CreateButton({
    Name = 'Auto Guess',
    Callback = function()
        runAutoFarmOnce()
    end,
})
-- Update loop for autofarm labels
spawn(function()
    local startTime = tick()
    while true do
        local elapsed = tick() - startTime
        local h = math.floor(elapsed / 3600)
        local m = math.floor((elapsed % 3600) / 60)
        local s = math.floor(elapsed % 60)
        timerLabel:Set(string.format('Timer: %d:%02d:%02d', h, m, s))
        local coins, candy = 0, 0
        -- Fetch Coins and Candy from specified GUI paths
        local success, result = pcall(function()
            local gui = game:GetService('Players').LocalPlayer.PlayerGui
                :FindFirstChild('MainGui')
            if gui then
                local holder = gui:FindFirstChild('Holder')
                local top = holder and holder:FindFirstChild('Top')
                local inner = top and top:FindFirstChild('Holder')
                if inner then
                    local coinsObj = inner:FindFirstChild('Coins')
                    local candyObj = inner:FindFirstChild('Candy')
                    if coinsObj and coinsObj:FindFirstChild('Amount') then
                        coins = tonumber(coinsObj.Amount.Text:gsub(',', ''))
                            or 0
                    end
                    if candyObj and candyObj:FindFirstChild('Amount') then
                        candy = tonumber(candyObj.Amount.Text:gsub(',', ''))
                            or 0
                    end
                end
            end
            return coins, candy
        end)
        if not success then
            coins, candy = 0, 0 -- Silently default to 0
        end
        moneyLabel:Set('Money: ' .. tostring(coins))
        candyLabel:Set('Candy: ' .. tostring(candy))
        -- Fetch Guilty Suspect from specified path
        local suspect = 'Unknown'
        local suspectSuccess, suspectResult = pcall(function()
            return game:GetService('ReplicatedStorage').Values.GuiltySuspect.Value
        end)
        if suspectSuccess then
            suspect = tostring(suspectResult) or 'Unknown'
        end
        guiltyLabel:Set('Guilty Suspect: ' .. suspect)
        task.wait(SETTINGS.TimerUpdateRate)
    end
end)
-- =======================
-- ESP TAB
-- =======================
local evidenceEspEnabled = false
local playerEspEnabled = false
local espColor = Color3.fromRGB(255, 0, 0)
local espTransparency = 0.5
local espThickness = 2
local showNames = true
local showDistance = true
local showHealth = true
local maxDistance = 1000
local EvidenceEspToggle = EspTab:CreateToggle({
    Name = 'Evidence ESP',
    CurrentValue = false,
    Flag = 'EvidenceEspToggle',
    Callback = function(Value)
        evidenceEspEnabled = Value
    end,
})
local PlayerEspToggle = EspTab:CreateToggle({
    Name = 'Player ESP',
    CurrentValue = false,
    Flag = 'PlayerEspToggle',
    Callback = function(Value)
        playerEspEnabled = Value
    end,
})
local EspColorPicker = EspTab:CreateColorPicker({
    Name = 'ESP Color',
    Color = Color3.fromRGB(255, 0, 0),
    Flag = 'EspColorPicker',
    Callback = function(Color)
        espColor = Color
    end,
})
local EspTransparencySlider = EspTab:CreateSlider({
    Name = 'ESP Transparency',
    Range = { 0, 1 },
    Increment = 0.1,
    CurrentValue = 0.5,
    Flag = 'EspTransparencySlider',
    Callback = function(Value)
        espTransparency = Value
    end,
})
local EspThicknessSlider = EspTab:CreateSlider({
    Name = 'ESP Thickness',
    Range = { 1, 5 },
    Increment = 1,
    CurrentValue = 2,
    Flag = 'EspThicknessSlider',
    Callback = function(Value)
        espThickness = Value
    end,
})
local ShowNamesToggle = EspTab:CreateToggle({
    Name = 'Show Names',
    CurrentValue = true,
    Flag = 'ShowNamesToggle',
    Callback = function(Value)
        showNames = Value
    end,
})
local ShowDistanceToggle = EspTab:CreateToggle({
    Name = 'Show Distance',
    CurrentValue = true,
    Flag = 'ShowDistanceToggle',
    Callback = function(Value)
        showDistance = Value
    end,
})
local ShowHealthToggle = EspTab:CreateToggle({
    Name = 'Show Health',
    CurrentValue = true,
    Flag = 'ShowHealthToggle',
    Callback = function(Value)
        showHealth = Value
    end,
})
local MaxDistanceSlider = EspTab:CreateSlider({
    Name = 'Max Distance',
    Range = { 100, 5000 },
    Increment = 100,
    CurrentValue = 1000,
    Flag = 'MaxDistanceSlider',
    Callback = function(Value)
        maxDistance = Value
    end,
})
-- ESP Implementation
local evidenceEsps = {}
local playerEsps = {}
local function createEsp(isPlayer)
    local box = Drawing.new('Square')
    box.Visible = false
    box.Color = espColor
    box.Thickness = espThickness
    box.Transparency = 1 - espTransparency
    box.Filled = false
    local nameText = Drawing.new('Text')
    nameText.Visible = false
    nameText.Color = espColor
    nameText.Size = 16
    nameText.Center = true
    nameText.Outline = true
    nameText.OutlineColor = Color3.fromRGB(0, 0, 0)
    local distanceText = Drawing.new('Text')
    distanceText.Visible = false
    distanceText.Color = espColor
    distanceText.Size = 14
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.OutlineColor = Color3.fromRGB(0, 0, 0)
    local healthText = Drawing.new('Text')
    healthText.Visible = false
    healthText.Color = espColor
    healthText.Size = 14
    healthText.Center = true
    healthText.Outline = true
    healthText.OutlineColor = Color3.fromRGB(0, 0, 0)
    return {
        box = box,
        name = nameText,
        distance = distanceText,
        health = healthText,
    }
end
-- For evidence
local activeEvidence = Workspace:WaitForChild('ActiveEvidence', 10)
if activeEvidence then
    activeEvidence.ChildAdded:Connect(function(child)
        if evidenceEspEnabled and child:IsA('BasePart') then
            evidenceEsps[child] = createEsp(false)
        end
    end)
    activeEvidence.ChildRemoved:Connect(function(child)
        if evidenceEsps[child] then
            evidenceEsps[child].box:Remove()
            evidenceEsps[child].name:Remove()
            evidenceEsps[child].distance:Remove()
            evidenceEsps[child].health:Remove()
            evidenceEsps[child] = nil
        end
    end)
end
-- For players
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if playerEspEnabled then
                playerEsps[player] = createEsp(true)
            end
        end)
        if player.Character and playerEspEnabled then
            playerEsps[player] = createEsp(true)
        end
    end
end
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        if playerEspEnabled then
            playerEsps[player] = createEsp(true)
        end
    end)
end)
Players.PlayerRemoving:Connect(function(player)
    if playerEsps[player] then
        playerEsps[player].box:Remove()
        playerEsps[player].name:Remove()
        playerEsps[player].distance:Remove()
        playerEsps[player].health:Remove()
        playerEsps[player] = nil
    end
end)
-- ESP update loop
spawn(function()
    while true do
        for object, esp in pairs(evidenceEsps) do
            if object then
                local pos, onScreen =
                    camera:WorldToViewportPoint(object.Position)
                local dist = (camera.CFrame.Position - object.Position).Magnitude
                if onScreen and dist <= maxDistance then
                    esp.box.Visible = true
                    local size = 500 / pos.Z
                    esp.box.Size = Vector2.new(size, size)
                    esp.box.Position = Vector2.new(
                        pos.X - esp.box.Size.X / 2,
                        pos.Y - esp.box.Size.Y / 2
                    )
                    esp.box.Color = espColor
                    esp.box.Transparency = 1 - espTransparency
                    esp.box.Thickness = espThickness
                    esp.name.Text = object.Name
                    esp.name.Position =
                        Vector2.new(pos.X, pos.Y - esp.box.Size.Y / 2 - 16)
                    esp.name.Visible = showNames
                    esp.distance.Text = math.floor(dist) .. 'm'
                    esp.distance.Position =
                        Vector2.new(pos.X, pos.Y + esp.box.Size.Y / 2)
                    esp.distance.Visible = showDistance
                    esp.health.Visible = false -- No health for evidence
                else
                    esp.box.Visible = false
                    esp.name.Visible = false
                    esp.distance.Visible = false
                    esp.health.Visible = false
                end
            end
        end
        for player, esp in pairs(playerEsps) do
            local char = player.Character
            if char then
                local hrp = char:FindFirstChild('HumanoidRootPart')
                local humanoid = char:FindFirstChild('Humanoid')
                if hrp then
                    local pos, onScreen =
                        camera:WorldToViewportPoint(hrp.Position)
                    local dist = (camera.CFrame.Position - hrp.Position).Magnitude
                    if onScreen and dist <= maxDistance then
                        esp.box.Visible = true
                        local size = 1000 / pos.Z
                        esp.box.Size = Vector2.new(size * 0.5, size)
                        esp.box.Position = Vector2.new(
                            pos.X - esp.box.Size.X / 2,
                            pos.Y - esp.box.Size.Y / 2
                        )
                        esp.box.Color = espColor
                        esp.box.Transparency = 1 - espTransparency
                        esp.box.Thickness = espThickness
                        esp.name.Text = player.Name
                        esp.name.Position =
                            Vector2.new(pos.X, pos.Y - esp.box.Size.Y / 2 - 16)
                        esp.name.Visible = showNames
                        esp.distance.Text = math.floor(dist) .. 'm'
                        esp.distance.Position =
                            Vector2.new(pos.X, pos.Y + esp.box.Size.Y / 2)
                        esp.distance.Visible = showDistance
                        if humanoid then
                            esp.health.Text = math.floor(humanoid.Health)
                                .. '/'
                                .. humanoid.MaxHealth
                            esp.health.Position = Vector2.new(
                                pos.X,
                                pos.Y + esp.box.Size.Y / 2 + 14
                            )
                            esp.health.Visible = showHealth
                        else
                            esp.health.Visible = false
                        end
                    else
                        esp.box.Visible = false
                        esp.name.Visible = false
                        esp.distance.Visible = false
                        esp.health.Visible = false
                    end
                end
            end
        end
        task.wait()
    end
end)
-- =======================
-- GAME VALUES TAB
-- =======================
local gameValueLabels = {}
local gameValueNames = {
    'GadgetPickingDone',
    'GadgetPickingTimeLeft',
    'GadgetRemainder',
    'GroupLoaded',
    'GroupSize',
    'GuiltySuspect',
    'HalloweenEnabled',
    'HalloweenEventEnabled',
    'Host',
    'HostPickedMap',
    'MapFolder',
    'MapLoaded',
    'SceneName',
    'SelectedMapName',
    'ServerType',
    'VotesForExit',
}
for _, name in ipairs(gameValueNames) do
    local label = GameValuesTab:CreateLabel(name .. ': Loading...')
    table.insert(gameValueLabels, label)
end
spawn(function()
    while true do
        for i, name in ipairs(gameValueNames) do
            local value = RS.Values:FindFirstChild(name)
            local valStr = value and tostring(value.Value) or 'Not Found'
            gameValueLabels[i]:Set(name .. ': ' .. valStr)
        end
        task.wait(1)
    end
end)
-- =======================
-- AUTO FARM VARIABLES
-- =======================
local roundHandled = false
local debounce = false
-- Helper function
local function notify(title, text, duration)
    print(string.format('[wbuhub] %s — %s', title or 'Info', text or ''))
    pcall(function()
        StarterGui:SetCore('SendNotification', {
            Title = tostring(title or 'wbuhub'),
            Text = tostring(text or ''),
            Duration = duration or 3,
        })
    end)
end
-- Find active map
local function findActiveMap()
    local mapFolder = Workspace:FindFirstChild('Map')
    if not mapFolder then
        return nil
    end
    for _, v in ipairs(mapFolder:GetChildren()) do
        if v:FindFirstChild('Exit') then
            return v
        end
    end
    return nil
end
-- Check if in lobby
local function isInLobby()
    local lobby = Workspace:FindFirstChild('Lobby')
    return lobby and #lobby:GetChildren() > 0
end
-- Auto-Play
spawn(function()
    local ok, err = pcall(function()
        local menuGui = playerGui:WaitForChild('MenuGui', 10)
        if not menuGui then
            return
        end
        local playBtn = menuGui:WaitForChild('Play', 5)
        if not playBtn then
            return
        end
        local click = playBtn:FindFirstChild('Click')
        local key = playBtn:FindFirstChild('Key')
        task.wait(0.5 + math.random() * 0.5)
        if click then
            if click:IsA('ClickDetector') then
                fireclickdetector(click)
            end
            if click:IsA('ProximityPrompt') then
                fireproximityprompt(click)
            end
        end
        task.wait(0.3 + math.random() * 0.2)
        if key then
            if key:IsA('ClickDetector') then
                fireclickdetector(key)
            end
            if key:IsA('ProximityPrompt') then
                fireproximityprompt(key)
            end
        end
        task.wait(0.5 + math.random() * 0.3)
        local events = RS:WaitForChild('Events', 5)
        if not events then
            return
        end
        local pressed = events:WaitForChild('PressedPlayButton', 5)
        if pressed then
            pressed:FireServer()
        end
        task.wait(0.4 + math.random() * 0.2)
        local playInvoke = events:WaitForChild('Play', 5)
        if playInvoke then
            playInvoke:InvokeServer()
        end
    end)
    if not ok then
        warn('[wbuhub] Auto-Play failed:', err)
    end
end)
-- Lobby Routine
function runLobbyRoutine()
    if debounce then
        return
    end
    debounce = true
    local ok, err = pcall(function()
        notify('Lobby', 'Lobby detected — starting routine', 2)
        local lobby = Workspace:FindFirstChild('Lobby')
        local lobbies = lobby and lobby:FindFirstChild('Lobbies')
        if not lobbies then
            return
        end
        local touches = {}
        for _, obj in ipairs(lobbies:GetDescendants()) do
            if obj.Name == 'TouchInterest' then
                table.insert(touches, obj.Parent)
            end
        end
        if #touches == 0 then
            return
        end
        local chosen = touches[math.random(1, #touches)]
        local character = LocalPlayer.Character
            or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:WaitForChild('HumanoidRootPart', 5)
        if hrp then
            firetouchinterest(hrp, chosen, 0)
            task.wait(0.1)
            firetouchinterest(hrp, chosen, 1)
            notify('AutoFarm', 'Random TouchInterest fired', 2)
        end
        task.wait(1)
        local args = { 1, 'Cursed Cathedral', 'Anyone' }
        RS:WaitForChild('Events')
            :WaitForChild('CreateParty')
            :FireServer(unpack(args))
        notify('AutoFarm', 'CreateParty fired', 2)
    end)
    if not ok then
        warn('[wbuhub] Lobby routine failed:', err)
    end
    debounce = false
end
-- AutoFarm Routine
function runAutoFarmOnce()
    if debounce then
        return
    end
    debounce = true
    local ok, err = pcall(function()
        notify('AutoFarm', 'Map detected — running sequence', 2)
        local currentMap = findActiveMap()
        if not currentMap then
            return
        end
        local exitObj = currentMap:FindFirstChild('Exit')
        local exitPrompt = exitObj
            and exitObj:FindFirstChildOfClass('ProximityPrompt')
        if exitPrompt then
            exitPrompt.MaxActivationDistance = math.huge
            fireproximityprompt(exitPrompt, 1, false)
            notify('AutoFarm', 'Exit ProximityPrompt fired', 2)
        end
        task.wait(0.25)
        local target = guiltySuspect.Value or 'Unknown'
        RS:WaitForChild('Events')
            :WaitForChild('AccuseSuspect')
            :FireServer(target)
        notify('AutoFarm', 'Accused suspect: ' .. tostring(target), 2)
        roundHandled = true
    end)
    if not ok then
        warn('[wbuhub] AutoFarm routine failed:', err)
    end
    debounce = false
end
-- Watcher
spawn(function()
    while true do
        if autoExecEnabled then
            local currentMap = findActiveMap()
            if currentMap and not roundHandled then
                runAutoFarmOnce()
            elseif not currentMap then
                roundHandled = false
                if isInLobby() then
                    runLobbyRoutine()
                end
            end
        end
        task.wait(0.9)
    end
end)
-- Character Added for re-enable
LocalPlayer.CharacterAdded:Connect(function()
    if autoExecEnabled then
        notify('AutoExec', 'AutoFarm re-enabled on respawn/teleport', 3)
    end
end)
notify('wbuhub', 'Thanks for using [wbuhub]!', 4)
